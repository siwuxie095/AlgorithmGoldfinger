package com.siwuxie095.algorithm.chapter0th.example7th;

/**
 * @author Jiajing Li
 * @date 2021-08-17 21:36:25
 */
public class Main {

    /**
     * ⼀、斐波那契数列
     *
     *
     * 1、暴力递归
     *
     * 斐波那契数列的数学形式就是递归的，写成代码就是这样：
     *
     * int fib(int N) {
     *     if (N == 0) return 0;
     *     if (N == 1 || N == 2) return 1;
     *     return fib(N - 1) + fib(N - 2);
     * }
     *
     * 这个不⽤多说了，学校⽼师讲递归的时候似乎都是拿这个举例。大家也知道这样写代码虽然简洁易懂，但是⼗分低效，
     * 低效在哪⾥？假设 n = 20，不妨画出递归树。
     *
     * PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨⼤帮助。
     *
     * 这个递归树怎么理解？就是说想要计算原问题 f(20)，就得先计算出⼦问题 f(19) 和 f(18)，然后要计算 f(19)，
     * 就要先算出⼦问题 f(18) 和 f(17)，以此类推。最后遇到 f(1) 或者 f(2) 的时候，结果已知，就能直接返回
     * 结果，递归树不再向下⽣⻓了。
     *
     * 递归算法的时间复杂度怎么计算？⼦问题个数乘以解决⼀个⼦问题需要的时间。
     *
     * ⼦问题个数，即递归树中节点的总数。显然⼆叉树节点总数为指数级别，所以⼦问题个数为 O(2^n)。
     *
     * 解决⼀个⼦问题的时间，在本算法中，没有循环，只有 f(n - 1) + f(n - 2) ⼀个加法操作，时间为 O(1)。
     *
     * 所以，这个算法的时间复杂度为 O(2^n)，即 指数级别，真是爆炸。
     *
     * 观察递归树，很明显发现了算法低效的原因：存在⼤量重复计算，⽐如 f(18) 被计算了两次，⽽且你可以看到，以
     * f(18) 为根的这个递归树体量巨⼤，多算⼀遍，会耗费巨⼤的时间。更何况，还不⽌ f(18) 这⼀个节点被重复计算，
     * 所以这个算法及其低效。
     *
     * 这就是动态规划问题的第⼀个性质：重叠⼦问题。下⾯来想办法解决这个问题。
     *
     *
     * 2、带备忘录的递归解法
     *
     * 明确了问题，其实就已经把问题解决了⼀半。既然耗时的原因是重复计算，那么可以造⼀个「备忘录」，每次算出
     * 某个⼦问题的答案后别急着返回，先记到「备忘录」⾥再返回；每次遇到⼀个⼦问题先去「备忘录」⾥查⼀查，如
     * 果发现之前已经解决过这个问题了，直接把答案拿出来⽤，不要再耗时去计算了。
     *
     * ⼀般使⽤⼀个数组充当这个「备忘录」，当然你也可以使⽤哈希表（字典），思想都是⼀样的。
     *
     * int fib(int N) {
     *     if (N == 0) return 0;
     *     // 备忘录全初始化为 0
     *     vector<int> memo(N + 1, 0);
     *     // 进行带备忘录的递归
     *     return helper(memo, N);
     * }
     *
     * int helper(vector<int>& memo, int n) {
     *     // base case
     *     if (n == 1 || n == 2) return 1;
     *     // 已经计算过
     *     if (memo[n] != 0) return memo[n];
     *     memo[n] = helper(memo, n - 1) + helper(memo, n - 2);
     *     return memo[n];
     * }
     *
     * 现在，再画出递归树，你就知道「备忘录」到底做了什么。
     *
     * 实际上，带「备忘录」的递归算法，把⼀棵存在巨量冗余的递归树通过「剪枝」，改造成了⼀幅不存在冗余的递归
     * 图，极⼤减少了⼦问题（即递归图中节点）的个数。
     *
     * 递归算法的时间复杂度怎么算？⼦问题个数乘以解决⼀个⼦问题需要的时间。
     *
     * ⼦问题个数，即图中节点的总数，由于本算法不存在冗余计算，⼦问题就是 f(1), f(2), f(3) ... f(20)，
     * 数量和输⼊规模 n = 20 成正⽐，所以⼦问题个数为 O(n)。
     *
     * 解决⼀个⼦问题的时间，同上，没有什么循环，时间为 O(1)。
     *
     * 所以，本算法的时间复杂度是 O(n)。⽐起暴⼒算法，是降维打击。
     *
     * ⾄此，带备忘录的递归解法的效率已经和迭代的动态规划解法⼀样了。实际上，这种解法和迭代的动态规划已经差
     * 不多了，只不过这种⽅法叫做「⾃顶向下」，动态规划叫做「⾃底向上」。
     *
     * 啥叫「⾃顶向下」？注意刚才的递归树（或者说图），是从上向下延伸，都是从⼀个规模较⼤的原问题⽐如说 f(20)，
     * 向下逐渐分解规模，直到 f(1) 和 f(2) 触底，然后逐层返回答案，这就叫「⾃顶向下」。
     *
     * 啥叫「⾃底向上」？反过来，直接从最底下，最简单，问题规模最⼩的 f(1) 和 f(2) 开始往上推，直到推到想要
     * 的答案 f(20)，这就是动态规划的思路，这也是为什么动态规划⼀般都脱离了递归，⽽是由循环迭代完成计算。
     *
     *
     * 3、dp 数组的迭代解法
     *
     * 有了上⼀步「备忘录」的启发，可以把这个「备忘录」独⽴出来成为⼀张表，叫做 DP table，在这张表上完成
     * 「⾃底向上」的推算岂不美哉！
     *
     * int fib(int N) {
     *     if (N == 0) return 0;
     *     if (N == 1 || N == 2) return 1;
     *     vector<int> dp(N + 1, 0);
     *     // base case
     *     dp[1] = dp[2] = 1;
     *     for (int i = 3; i <= N; i++)
     *         dp[i] = dp[i - 1] + dp[i - 2];
     *     return dp[N];
     * }
     *
     * 画个图就很好理解了，⽽且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算⽽已。实际
     * 上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，
     * ⼤部分情况下，效率也基本相同。
     *
     * 这⾥，引出「状态转移⽅程」这个名词，实际上就是描述问题结构的数学形式：
     *
     * n = 1， 2 时，f(n) = 1
     * n > 2 时，f(n) = f(n-1) + f(n-2)
     *
     * 为啥叫「状态转移⽅程」？为了听起来⾼端。你把 f(n) 想做⼀个状态 n，这个状态 n 是由状态 n - 1 和状
     * 态 n - 2 相加转移⽽来，这就叫状态转移，仅此⽽已。
     *
     * 你会发现，上⾯的⼏种解法中的所有操作，例如 return f(n - 1) + f(n - 2) 或 dp[i] = dp[i - 1] +
     * dp[i - 2]，以及对备忘录或 DP table 的初始化操作，都是围绕这个⽅程式的不同表现形式。
     *
     * 可⻅列出「状态转移⽅程」的重要性，它是解决问题的核⼼。很容易发现，其实状态转移⽅程直接代表着暴⼒解法。
     *
     * 千万不要看不起暴⼒解，动态规划问题最困难的就是写出状态转移⽅程，即这个暴⼒解。优化⽅法⽆⾮是⽤备忘录
     * 或者 DP table，再⽆奥妙可⾔。
     *
     * 这个例⼦的最后，讲⼀个细节优化。不难发现，根据斐波那契数列的状态转移⽅程，当前状态只和之前的两个状态
     * 有关，其实并不需要那么⻓的⼀个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就⾏了。所以，
     * 可以进⼀步优化，把空间复杂度降为 O(1)：
     *
     * int fib(int N) {
     *     if (N == 0) return 0;
     *     if (N == 2 || N == 1)
     *         return 1;
     *     int prev = 1, curr = 1;
     *     for (int i = 3; i <= N; i++) {
     *         int sum = prev + curr;
     *         prev = curr;
     *         curr = sum;
     *     }
     *     return curr;
     * }
     *
     * 有⼈会问，动态规划的另⼀个重要特性「最优⼦结构」，怎么没有涉及？后续会涉及。斐波那契数列的例⼦严格
     * 来说不算动态规划，因为没有涉及求最值，以上旨在演⽰算法设计螺旋上升的过程。
     *
     * 后续将会介绍第⼆个例⼦，凑零钱问题。
     */
    public static void main(String[] args) {

    }

}
