package com.siwuxie095.algorithm.chapter0th.example13th;

/**
 * @author Jiajing Li
 * @date 2021-08-18 22:23:14
 */
public class Main {

    /**
     * 三、总结
     *
     * 回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做⼀些操作，算法框架如下：
     *
     * def backtrack(...):
     *     for 选择 in 选择列表:
     *         做选择
     *         backtrack(...)
     *         撤销选择
     *
     * 写 backtrack 函数时，需要维护⾛过的「路径」和当前可以做的「选择列表」，当触发「结束条件」
     * 时，将「路径」记⼊结果集。
     *
     * 其实想想看，回溯算法和动态规划是不是有点像呢？动态规划的三个需要明确的点就是「状态」「选择」
     * 和 「base case」，是不是就对应着⾛过的「路径」，当前的「选择列表」和「结束条件」？
     *
     * 某种程度上说，动态规划的暴⼒求解阶段就是回溯算法。只是有的问题具有重叠⼦问题性质，可以⽤ dp
     * table 或者备忘录优化，将递归树⼤幅剪枝，这就变成了动态规划。⽽今天的两个问题，都没有重叠⼦
     * 问题，也就是回溯算法问题了，复杂度⾮常⾼是不可避免的。
     */
    public static void main(String[] args) {

    }

}
