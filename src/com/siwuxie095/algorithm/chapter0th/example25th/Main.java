package com.siwuxie095.algorithm.chapter0th.example25th;

/**
 * @author Jiajing Li
 * @date 2021-08-21 16:38:28
 */
public class Main {

    /**
     * 滑动窗口解题套路框架
     *
     * 关于双指针的快慢指针和左右指针的用法，后续会进行介绍。这里就解决一类最难掌握的双指针技巧：滑动窗口技巧。
     * 总结出一套框架，可以保你闭着眼睛都能写出正确的解法。
     *
     * 说起滑动窗口算法，很多读者都会头疼。这个算法技巧的思路非常简单，就是维护一个窗口，不断滑动，然后更新答
     * 案么。LeetCode 上有起码 10 道运用滑动窗口算法的题目，难度都是中等和困难。该算法的大致逻辑如下：
     *
     * int left = 0, right = 0;
     *
     * while (right < s.size()) {
     *     // 增大窗口
     *     window.add(s[right]);
     *     right++;
     *
     *     while (window needs shrink) {
     *         // 缩小窗口
     *         window.remove(s[left]);
     *         left++;
     *     }
     * }
     *
     * 这个算法技巧的时间复杂度是 O(N)，比字符串暴力算法要高效得多。
     *
     * 其实困扰大家的，不是算法的思路，而是各种细节问题。比如说如何向窗口中添加新元素，如何缩小窗口，在窗口滑
     * 动的哪个阶段更新结果。即便你明白了这些细节，也容易出 bug，找 bug 还不知道怎么找，真的挺让人心烦的。
     *
     * 所以这里提供了一套滑动窗口算法的代码框架，连再哪里做输出 debug 都给你写好了，以后遇到相关的问题，你就
     * 默写出来如下框架然后改三个地方就行，还不会出 bug：
     *
     *  // 滑动窗口算法框架
     * void slidingWindow(string s, string t) {
     *     unordered_map<char, int> need, window;
     *     for (char c : t) need[c]++;
     *
     *     int left = 0, right = 0;
     *     int valid = 0;
     *     while (right < s.size()) {
     *         // c 是将移入窗口的字符
     *         char c = s[right];
     *         // 右移窗口
     *         right++;
     *         // 进行窗口内数据的一系列更新
     *         ...
     *
     *         // debug 输出的位置
     *         printf("window: [%d, %d)\n", left, right);
     *
     *         // 判断左侧窗口是否要收缩
     *         while (window needs shrink) {
     *             // d 是将移出窗口的字符
     *             char d = s[left];
     *             // 左移窗口
     *             left++;
     *             // 进行窗口内数据的一系列更新
     *             ...
     *         }
     *     }
     * }
     *
     * 其中两处 ... 表示的更新窗口数据的地方，到时候你直接往里面填就行了。
     *
     * 而且，这两个 ... 处的操作分别是右移和左移窗口更新操作，等会你会发现它们操作是完全对称的。
     *
     * 说句题外话，很多人喜欢执着于表象，不喜欢探求问题的本质。比如说有很多人评论这个框架，说什么散列表速度慢，
     * 不如用数组代替散列表；还有很多人喜欢把代码写得特别短小，说这样代码太多余，影响编译速度，LeetCode 上速
     * 度不够快。
     *
     * 其实算法看的是时间复杂度，你能确保自己的时间复杂度最优，就行了。至于 LeetCode 所谓的运行速度，那个都
     * 是玄学，只要不是慢的离谱就没啥问题，根本不值得你从编译层面优化，不要舍本逐末……
     *
     * 这里的重点在于算法思想，你把框架思维了然于心，然后随你魔改代码好吧，你高兴就好。
     *
     * 言归正传，后续会直接上四道 LeetCode 原题来套这个框架，其中第一道题会详细说明其原理，后面四道就直接闭
     * 眼睛秒杀了。
     *
     * 因为滑动窗口很多时候都是在处理字符串相关的问题，Java 处理字符串不方便，所以本文代码为 C++ 实现。不会
     * 用到什么编程方面的奇技淫巧，但是还是简单介绍一下一些用到的数据结构，以免有人因为语言的细节问题阻碍对算
     * 法思想的理解：
     *
     * unordered_map 就是哈希表（字典），它的一个方法 count(key) 相当于 Java 的 containsKey(key)
     * 可以判断键 key 是否存在。
     *
     * 可以使用方括号访问键对应的值 map[key]。需要注意的是，如果该 key 不存在，C++ 会自动创建这个 key，
     * 并把 map[key] 赋值为 0。
     *
     * 所以代码中多次出现的 map[key]++ 相当于 Java 的 map.put(key, map.getOrDefault(key, 0) + 1)。
     */
    public static void main(String[] args) {

    }

}
