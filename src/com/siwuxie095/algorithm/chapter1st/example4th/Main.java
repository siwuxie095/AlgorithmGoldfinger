package com.siwuxie095.algorithm.chapter1st.example4th;

/**
 * @author Jiajing Li
 * @date 2021-08-24 07:52:31
 */
public class Main {

    /**
     * 手把手带你刷二叉树（第一期）
     *
     * 这里不仅会让你学会算法套路，还可以顺便去 LeetCode 上拿下如下题目：
     *
     * 226.翻转二叉树（简单）
     * 114.二叉树展开为链表（中等）
     * 116.填充每个节点的下一个右侧节点指针（中等）
     *
     * 之前多次强调，先刷二叉树的题目，先刷二叉树的题目，先刷二叉树的题目，因为很多经典算法，以及所有回溯、
     * 动规、分治算法，其实都是树的问题，而树的问题就永远逃不开树的递归遍历框架这几行破代码：
     *
     * // 二叉树遍历框架
     * void traverse(TreeNode root) {
     *     // 前序遍历
     *     traverse(root.left)
     *     // 中序遍历
     *     traverse(root.right)
     *     // 后序遍历
     * }
     *
     * 很多人说觉得「递归」非常难以理解，说实话，递归解法应该是最简单，最容易理解的才对，行云流水地写递归
     * 代码是学好算法的基本功，而二叉树相关的题目就是最练习递归基本功，最练习框架思维的。
     *
     * 下面先花一些篇幅说明二叉树算法的重要性。
     *
     *
     *
     * 一、二叉树的重要性
     *
     * 举个例子，比如说经典算法「快速排序」和「归并排序」，对于这两个算法，你有什么理解？快速排序其实就是
     * 个二叉树的前序遍历，归并排序其实就是个二叉树的后序遍历。
     *
     * 为什么快速排序和归并排序能和二叉树扯上关系？来简单分析一下它们的算法思想和代码框架：
     *
     * （1）快速排序的逻辑是，若要对 nums[lo..hi] 进行排序，先找一个分界点 p，通过交换元素使得
     * nums[lo..p-1] 都小于等于 nums[p]，且 nums[p+1..hi] 都大于 nums[p]，然后递归地去
     * nums[lo..p-1] 和 nums[p+1..hi] 中寻找新的分界点，最后整个数组就被排序了。
     *
     * 快速排序的代码框架如下：
     *
     * void sort(int[] nums, int lo, int hi) {
     *     // 前序遍历位置
     *     // 通过交换元素构建分界点 p
     *     int p = partition(nums, lo, hi);
     *
     *     sort(nums, lo, p - 1);
     *     sort(nums, p + 1, hi);
     * }
     *
     * 先构造分界点，然后去左右子数组构造分界点，你看这不就是一个二叉树的前序遍历吗？
     *
     * （2）再说说归并排序的逻辑，若要对 nums[lo..hi] 进行排序，先对 nums[lo..mid] 排序，再对
     * nums[mid+1..hi] 排序，最后把这两个有序的子数组合并，整个数组就排好序了。
     *
     * 归并排序的代码框架如下：
     *
     * void sort(int[] nums, int lo, int hi) {
     *     int mid = (lo + hi) / 2;
     *     sort(nums, lo, mid);
     *     sort(nums, mid + 1, hi);
     *
     *     // 后序遍历位置
     *     // 合并两个排好序的子数组
     *     merge(nums, lo, mid, hi);
     * }
     *
     * 先对左右子数组排序，然后合并（类似合并有序链表的逻辑），你看这是不是二叉树的后序遍历框架？另外，这
     * 不就是传说中的分治算法嘛，不过如此呀。
     *
     * 如果你一眼就识破这些排序算法的底细，还需要背这些算法代码吗？这不是手到擒来，从框架慢慢扩展就能写出
     * 算法了。
     *
     * 说了这么多，旨在说明，二叉树的算法思想的运用广泛，甚至可以说，只要涉及递归，都可以抽象成二叉树的问
     * 题，所以这里和后续的手把手带你刷二叉树（第二期）以及 手把手刷二叉树（第三期），直接上几道比较有意
     * 思，且能体现出递归算法精妙的二叉树题目，手把手教你怎么用算法框架搞定它们。
     *
     *
     *
     * 二、写递归算法的秘诀
     *
     * 写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要
     * 跳入递归的细节。
     *
     * 怎么理解呢，用一个具体的例子来说，比如说让你计算一棵二叉树共有几个节点：
     *
     * // 定义：count(root) 返回以 root 为根的树有多少节点
     * int count(TreeNode root) {
     *     // base case
     *     if (root == null) return 0;
     *     // 自己加上子树的节点数就是整棵树的节点数
     *     return 1 + count(root.left) + count(root.right);
     * }
     *
     * 这个问题非常简单，大家应该都会写这段代码，root 本身就是一个节点，加上左右子树的节点数就是以 root
     * 为根的树的节点总数。
     *
     * 左右子树的节点数怎么算？其实就是计算根为 root.left 和 root.right 两棵树的节点数呗，按照定义，
     * 递归调用 count 函数即可算出来。
     *
     * 写树相关的算法，简单说就是，先搞清楚当前 root 节点「该做什么」以及「什么时候做」，然后根据函数
     * 定义递归调用子节点，递归调用会让孩子节点做相同的事情。
     *
     * 所谓「该做什么」就是让你想清楚写什么代码能够实现题目想要的效果，所谓「什么时候做」，就是让你思考
     * 这段代码到底应该写在前序、中序还是后序遍历的代码位置上。
     *
     * 接下来看几道算法题目实操一下。
     *
     *
     *
     * 三、算法实践
     *
     * 第一题、翻转二叉树
     *
     * 先从简单的题开始，看看力扣第 226 题「翻转二叉树」，输入一个二叉树根节点 root，让你把整棵树镜像
     * 翻转，比如输入的二叉树如下：
     *
     *      4
     *    /   \
     *   2     7
     *  / \   / \
     * 1   3 6   9
     *
     * 算法原地翻转二叉树，使得以 root 为根的树变成：
     *
     *      4
     *    /   \
     *   7     2
     *  / \   / \
     * 9   6 3   1
     *
     * 通过观察，发现只要把二叉树上的每一个节点的左右子节点进行交换，最后的结果就是完全翻转之后的二叉树。
     *
     * 可以直接写出解法代码：
     *
     * // 将整棵树的节点翻转
     * TreeNode invertTree(TreeNode root) {
     *     // base case
     *     if (root == null) {
     *         return null;
     *     }
     *
     *     // 前序遍历位置
     *     // root 节点需要交换它的左右子节点
     *     TreeNode tmp = root.left;
     *     root.left = root.right;
     *     root.right = tmp;
     *
     *     // 让左右子节点继续翻转它们的子节点
     *     invertTree(root.left);
     *     invertTree(root.right);
     *
     *     return root;
     * }
     *
     * 这道题目比较简单，关键思路在于发现翻转整棵树就是交换每个节点的左右子节点，于是把交换左右子节点的
     * 代码放在了前序遍历的位置。
     *
     * 值得一提的是，如果把交换左右子节点的代码复制粘贴到后序遍历的位置也是可以的，但是直接放到中序遍历
     * 的位置是不行的，请你想一想为什么？
     *
     * 首先讲这道题目是想告诉你，二叉树题目的一个难点就是，如何把题目的要求细化成每个节点需要做的事情。
     *
     * 这种洞察力需要多刷题训练，下面看下一道题。
     *
     *
     * 第二题、填充二叉树节点的右侧指针
     *
     * 这是力扣第 116 题，看下题目：
     *
     * 给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
     *
     * struct Node {
     *   int val;
     *   Node *left;
     *   Node *right;
     *   Node *next;
     * }
     *
     * 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针
     * 设置为 NULL。
     *
     * 初始状态下，所有 next 指针都被设置为 NULL。
     *
     * 进阶：
     *
     * 你只能使用常量级额外空间。
     * 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。
     *
     *
     * 题目的意思就是把二叉树的每一层节点都用 next 指针连接起来，而且题目说了，输入是一棵「完美二叉树」，
     * 形象地说整棵二叉树是一个正三角形，除了最右侧的节点 next 指针会指向 null，其他节点的右侧一定有
     * 相邻的节点。
     *
     * 这道题怎么做呢？把每一层的节点穿起来，是不是只要把每个节点的左右子节点都穿起来就行了？
     *
     * 可以模仿上一道题，写出如下代码：
     *
     * Node connect(Node root) {
     *     if (root == null || root.left == null) {
     *         return root;
     *     }
     *
     *     root.left.next = root.right;
     *
     *     connect(root.left);
     *     connect(root.right);
     *
     *     return root;
     * }
     *
     * 这样其实有很大问题，因为不属于同一个父节点的子节点就没办法被穿起来，这是不符合题意的。
     *
     * 回想刚才说的，二叉树的问题难点在于，如何把题目的要求细化成每个节点需要做的事情，但是如果只依赖一个
     * 节点的话，肯定是没办法连接「跨父节点」的两个相邻节点的。
     *
     * 那么，这里的做法就是增加函数参数，一个节点做不到，就给他安排两个节点，「将每一层二叉树节点连接起来」
     * 可以细化成「将每两个相邻节点都连接起来」：
     *
     * // 主函数
     * Node connect(Node root) {
     *     if (root == null) return null;
     *     connectTwoNode(root.left, root.right);
     *     return root;
     * }
     *
     * // 辅助函数
     * void connectTwoNode(Node node1, Node node2) {
     *     if (node1 == null || node2 == null) {
     *         return;
     *     }
     *     // 前序遍历位置
     *     // 将传入的两个节点连接
     *     node1.next = node2;
     *
     *     // 连接相同父节点的两个子节点
     *     connectTwoNode(node1.left, node1.right);
     *     connectTwoNode(node2.left, node2.right);
     *     // 连接跨越父节点的两个子节点
     *     connectTwoNode(node1.right, node2.left);
     * }
     *
     * 这样，connectTwoNode 函数不断递归，可以无死角覆盖整棵二叉树，将所有相邻节点都连接起来，也就避免了
     * 之前出现的问题，这道题就解决了。
     *
     *
     * 第三题、将二叉树展开为链表
     *
     * 这是力扣第 114 题，看下题目：
     *
     * 给你二叉树的根结点 root ，请你将它展开为一个单链表：
     *
     * 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null。
     * 展开后的单链表应该与二叉树 先序遍历 顺序相同。
     *
     * 函数签名如下：
     *
     * void flatten(TreeNode root);
     *
     * 尝试给出这个函数的定义：
     *
     * 给 flatten 函数输入一个节点 root，那么以 root 为根的二叉树就会被拉平为一条链表。
     *
     * 再梳理一下，如何按题目要求把一棵树拉平成一条链表？很简单，以下流程：
     *
     * 1、将 root 的左子树和右子树拉平。
     * 2、将 root 的右子树接到左子树下方，然后将整个左子树作为右子树。
     *
     * 上面两步看起来最难的应该是第一步对吧，如何把 root 的左右子树拉平？其实很简单，按照 flatten 函数的
     * 定义，对 root 的左右子树递归调用 flatten 函数即可：
     *
     * // 定义：将以 root 为根的树拉平为链表
     * void flatten(TreeNode root) {
     *     // base case
     *     if (root == null) return;
     *
     *     flatten(root.left);
     *     flatten(root.right);
     *
     *     // 后序遍历位置
     *     // 1、左右子树已经被拉平成一条链表
     *     TreeNode left = root.left;
     *     TreeNode right = root.right;
     *
     *     // 2、将左子树作为右子树
     *     root.left = null;
     *     root.right = left;
     *
     *     // 3、将原先的右子树接到当前右子树的末端
     *     TreeNode p = root;
     *     while (p.right != null) {
     *         p = p.right;
     *     }
     *     p.right = right;
     * }
     *
     * 你看，这就是递归的魅力，你说 flatten 函数是怎么把左右子树拉平的？说不清楚，但是只要知道 flatten
     * 的定义如此，相信这个定义，让 root 做它该做的事情，然后 flatten 函数就会按照定义工作。
     *
     * 另外注意递归框架是后序遍历，因为要先拉平左右子树才能进行后续操作。
     *
     * 至此，这道题也解决了。
     *
     *
     *
     * 四、总结
     *
     * 递归算法的关键要明确函数的定义，相信这个定义，而不要跳进递归细节。
     *
     * 写二叉树的算法题，都是基于递归框架的，先要搞清楚 root 节点它自己要做什么，然后根据题目要求选择使用
     * 前序，中序，后续的递归框架。
     *
     * 二叉树题目的难点在于如何通过题目的要求思考出每一个节点需要做什么，这个只能通过多刷题进行练习了。
     */
    public static void main(String[] args) {

    }

}
