package com.siwuxie095.algorithm.chapter3rd.example3rd;

/**
 * @author Jiajing Li
 * @date 2021-09-28 22:09:15
 */
public class Main {

    /**
     * 回溯算法最佳实践：解数独
     *
     * 这里不仅会让你学会算法套路，还可以顺便去 LeetCode 上拿下如下题目：
     *
     * 37.解数独（困难）
     *
     * 经常拿回溯算法来说事儿的，无非就是八皇后问题和数独问题了。那这里就通过实际且有趣的例子来讲一下如何用
     * 回溯算法来解决数独问题。
     *
     *
     *
     * 一、直观感受
     *
     * 说实话，小的时候也尝试过玩数独游戏，但从来都没有完成过一次。做数独是有技巧的，记得一些比较专业的数独
     * 游戏软件，他们会教你玩数独的技巧，不过这些技巧都太复杂，根本就没有兴趣看下去。
     *
     * 不过自从学习了算法，多困难的数独问题都拦不住了。
     *
     * 那么计算机如何解决数独问题呢？其实非常的简单，就是穷举嘛。
     *
     * 算法的核心思路非常非常的简单，就是对每一个空着的格子穷举 1 到 9，如果遇到不合法的数字（在同一行或同
     * 一列或同一个 3×3 的区域中存在相同的数字）则跳过，如果找到一个合法的数字，则继续穷举下一个空格子。
     *
     * 对于数独游戏，也许还会有另一个误区：就是下意识地认为如果给定的数字越少那么这个局面的难度就越大。
     *
     * 这个结论对人来说应该没毛病，但对于计算机而言，给的数字越少，反而穷举的步数就越少，得到答案的速度越快，
     * 至于为什么，后面探讨代码实现的时候会讲。
     *
     * 言归正传，下面就来具体探讨一下如何用算法来求解数独问题。
     *
     *
     *
     * 二、代码实现
     *
     * LeetCode 第 37 题就是解数独的问题，算法函数签名如下：
     *
     * void solveSudoku(char[][] board);
     *
     * 输入是一个 9x9 的棋盘，空白格子用点号字符 . 表示，算法需要在原地修改棋盘，将空白格子填上数字，得到
     * 一个可行解。
     *
     * 至于数独的要求，大家想必都很熟悉了，每行，每列以及每一个 3×3 的小方格都不能有相同的数字出现。那么，
     * 现在直接套回溯框架即可求解。
     *
     * 求解数独的思路很简单粗暴，就是对每一个格子所有可能的数字进行穷举。对于每个位置，应该如何穷举，有几个
     * 选择呢？很简单啊，从 1 到 9 就是选择，全部试一遍不就行了：
     *
     * // 对 board[i][j] 进行穷举尝试
     * void backtrack(char[][] board, int i, int j) {
     *     int m = 9, n = 9;
     *     for (char ch = '1'; ch <= '9'; ch++) {
     *         // 做选择
     *         board[i][j] = ch;
     *         // 继续穷举下一个
     *         backtrack(board, i, j + 1);
     *         // 撤销选择
     *         board[i][j] = '.';
     *     }
     * }
     *
     * emmm，再继续细化，并不是 1 到 9 都可以取到的，有的数字不是不满足数独的合法条件吗？而且现在只是给 j
     * 加一，那如果 j 加到最后一列了，怎么办？
     *
     * 很简单，当 j 到达超过每一行的最后一个索引时，转为增加 i 开始穷举下一行，并且在穷举之前添加一个判断，
     * 跳过不满足条件的数字：
     *
     * void backtrack(char[][] board, int i, int j) {
     *     int m = 9, n = 9;
     *     if (j == n) {
     *         // 穷举到最后一列的话就换到下一行重新开始。
     *         backtrack(board, i + 1, 0);
     *         return;
     *     }
     *
     *     // 如果该位置是预设的数字，不用我们操心
     *     if (board[i][j] != '.') {
     *         backtrack(board, i, j + 1);
     *         return;
     *     }
     *
     *     for (char ch = '1'; ch <= '9'; ch++) {
     *         // 如果遇到不合法的数字，就跳过
     *         if (!isValid(board, i, j, ch))
     *             continue;
     *
     *         board[i][j] = ch;
     *         backtrack(board, i, j + 1);
     *         board[i][j] = '.';
     *     }
     * }
     *
     * // 判断 board[i][j] 是否可以填入 n
     * boolean isValid(char[][] board, int r, int c, char n) {
     *     for (int i = 0; i < 9; i++) {
     *         // 判断行是否存在重复
     *         if (board[r][i] == n) return false;
     *         // 判断列是否存在重复
     *         if (board[i][c] == n) return false;
     *         // 判断 3 x 3 方框是否存在重复
     *         if (board[(r/3)*3 + i/3][(c/3)*3 + i%3] == n)
     *             return false;
     *     }
     *     return true;
     * }
     *
     * emmm，现在基本上差不多了，还剩最后一个问题：这个算法没有 base case，永远不会停止递归。这个好办，
     * 什么时候结束递归？显然 r == m 的时候就说明穷举完了最后一行，完成了所有的穷举，就是 base case。
     *
     * 另外，上面也提到过，为了减少复杂度，可以让 backtrack 函数返回值为 boolean，如果找到一个可行解
     * 就返回 true，这样就可以阻止后续的递归。只找一个可行解，也是题目的本意。
     *
     * 最终代码修改如下：
     *
     * boolean backtrack(char[][] board, int i, int j) {
     *     int m = 9, n = 9;
     *     if (j == n) {
     *         // 穷举到最后一列的话就换到下一行重新开始。
     *         return backtrack(board, i + 1, 0);
     *     }
     *     if (i == m) {
     *         // 找到一个可行解，触发 base case
     *         return true;
     *     }
     *
     *     if (board[i][j] != '.') {
     *         // 如果有预设数字，不用我们穷举
     *         return backtrack(board, i, j + 1);
     *     }
     *
     *     for (char ch = '1'; ch <= '9'; ch++) {
     *         // 如果遇到不合法的数字，就跳过
     *         if (!isValid(board, i, j, ch))
     *             continue;
     *
     *         board[i][j] = ch;
     *         // 如果找到一个可行解，立即结束
     *         if (backtrack(board, i, j + 1)) {
     *             return true;
     *         }
     *         board[i][j] = '.';
     *     }
     *     // 穷举完 1~9，依然没有找到可行解，此路不通
     *     return false;
     * }
     *
     * boolean isValid(char[][] board, int r, int c, char n) {
     *     // 见上文
     * }
     *
     * 现在可以回答一下之前的问题，为什么有时候算法执行的次数多，有时候少？为什么对于计算机而言，确定的
     * 数字越少，反而算出答案的速度越快？
     *
     * 已经实现了一遍算法，掌握了其原理，回溯就是从 1 开始对每个格子穷举，最后只要试出一个可行解，就会
     * 立即停止后续的递归穷举。所以暴力试出答案的次数和随机生成的棋盘关系很大，这个是说不准的。
     *
     * 那么你可能问，既然运行次数说不准，那么这个算法的时间复杂度是多少呢？
     *
     * 对于这种时间复杂度的计算，只能给出一个最坏情况，也就是 O(9^M)，其中 M 是棋盘中空着的格子数量。
     * 你想嘛，对每个空格子穷举 9 个数，结果就是指数级的。
     *
     * 这个复杂度非常高，但稍作思考就能发现，实际上并没有真的对每个空格都穷举 9 次，有的数字会跳过，有
     * 的数字根本就没有穷举，因为当找到一个可行解的时候就立即结束了，后续的递归都没有展开。
     *
     * 这个 O(9^M) 的复杂度实际上是完全穷举，或者说是找到所有可行解的时间复杂度。
     *
     * 如果给定的数字越少，相当于给出的约束条件越少，对于计算机这种穷举策略来说，是更容易进行下去，而不
     * 容易走回头路进行回溯的，所以说如果仅仅找出一个可行解，这种情况下穷举的速度反而比较快。
     *
     * 至此，回溯算法就完成了。
     */
    public static void main(String[] args) {

    }

}
