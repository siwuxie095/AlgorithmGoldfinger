package com.siwuxie095.algorithm.chapter3rd.example10th;

/**
 * @author Jiajing Li
 * @date 2021-10-03 15:42:01
 */
@SuppressWarnings("all")
public class Main {

    /**
     * 如何寻找缺失的元素
     *
     * 这里不仅会让你学会算法套路，还可以顺便去 LeetCode 上拿下如下题目：
     *
     * 448.找到所有数组中消失的数字（简单）
     *
     * 这里聊一道巧妙的题目。
     *
     * 题目非常简单：
     *
     * 给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内
     * 但没有出现在 nums 中的数字，并以数组的形式返回结果。
     *
     *
     * 给一个长度为 n 的数组，其索引应该在 [0,n)，但是现在你要装进去 n + 1 个元素 [0,n]，那么肯定有一
     * 个元素装不下嘛，请你找出这个缺失的元素。
     *
     * 这道题不难的，应该很容易想到，把这个数组排个序，然后遍历一遍，不就很容易找到缺失的那个元素了吗？
     *
     * 或者说，借助数据结构的特性，用一个 HashSet 把数组里出现的数字都储存下来，再遍历 [0,n] 之间的数字，
     * 去 HashSet 中查询，也可以很容易查出那个缺失的元素。
     *
     * 排序解法的时间复杂度是 O(NlogN)，HashSet 的解法时间复杂度是 O(N)，但是还需要 O(N) 的空间复杂度
     * 存储 HashSet。
     *
     * 第三种方法是位运算。
     *
     * 对于异或运算（^），有一个特殊性质：
     *
     * 一个数和它本身做异或运算结果为 0，一个数和 0 做异或运算还是它本身。
     *
     * 而且异或运算满足交换律和结合律，也就是说：
     *
     * 2 ^ 3 ^ 2 = 3 ^ (2 ^ 2) = 3 ^ 0 = 3
     *
     * 而这道题索就可以通过这些性质巧妙算出缺失的那个元素。比如说 nums = [0,3,1,4]：
     *
     * 如何找这个落单的数字呢，只要把所有的元素和索引做异或运算，成对儿的数字都会消为 0，只有这个落单的元
     * 素会剩下，也就达到了目的。
     *
     * int missingNumber(int[] nums) {
     *     int n = nums.length;
     *     int res = 0;
     *     // 先和新补的索引异或一下
     *     res ^= n;
     *     // 和其他的元素、索引做异或
     *     for (int i = 0; i < n; i++)
     *         res ^= i ^ nums[i];
     *     return res;
     * }
     *
     * 由于异或运算满足交换律和结合律，所以总是能把成对儿的数字消去，留下缺失的那个元素的。
     *
     * 至此，时间复杂度 O(N)，空间复杂度 O(1)，已经达到了最优，是否就应该打道回府了呢？
     *
     * 如果这样想，说明受算法的毒害太深，随着学习的知识越来越多，反而容易陷入思维定式，这个问题其实还有一
     * 个特别简单的解法：等差数列求和公式。
     *
     * 题目的意思可以这样理解：现在有个等差数列 0, 1, 2,..., n，其中少了某一个数字，请你把它找出来。那
     * 这个数字不就是 sum(0,1,..n) - sum(nums) 嘛？
     *
     * int missingNumber(int[] nums) {
     *     int n = nums.length;
     *     // 公式：(首项 + 末项) * 项数 / 2
     *     int expect = (0 + n) * (n + 1) / 2;
     *
     *     int sum = 0;
     *     for (int x : nums)
     *         sum += x;
     *     return expect - sum;
     *
     * 你看，这种解法应该是最简单的。
     *
     * 做到这一步了，是否就应该打道回府了呢？
     *
     * 如果这样想，说明对细节的把控还差点火候。在用求和公式计算 expect 时，你考虑过整型溢出吗？如果相乘
     * 的结果太大导致溢出，那么结果肯定是错误的。
     *
     * 刚才的思路是把两个和都加出来然后相减，为了避免溢出，干脆一边求和一边减算了。很类似刚才位运算解法的
     * 思路，仍然假设 nums = [0,3,1,4]，先补一位索引再让元素跟索引配对。
     *
     * 让每个索引减去其对应的元素，再把相减的结果加起来，不就是那个缺失的元素吗？
     *
     * public int missingNumber(int[] nums) {
     *     int n = nums.length;
     *     int res = 0;
     *     // 新补的索引
     *     res += n - 0;
     *     // 剩下索引和元素的差加起来
     *     for (int i = 0; i < n; i++)
     *         res += i - nums[i];
     *     return res;
     * }
     *
     * 由于加减法满足交换律和结合律，所以总是能把成对儿的数字消去，留下缺失的那个元素的。
     *
     * 至此这道算法题目经历九曲十八弯，终于再也没有什么坑了。
     */
    public static void main(String[] args) {

    }

}
