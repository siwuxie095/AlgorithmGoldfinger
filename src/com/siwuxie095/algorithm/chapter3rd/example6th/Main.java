package com.siwuxie095.algorithm.chapter3rd.example6th;

/**
 * @author Jiajing Li
 * @date 2021-10-03 14:52:29
 */
public class Main {

    /**
     * 常用的位操作
     *
     * 这里不仅会让你学会算法套路，还可以顺便去 LeetCode 上拿下如下题目：
     *
     * 191.位1的个数（简单）
     * 231.2的幂（简单）
     *
     * 这里分两部分，第一部分列举几个有趣的位操作，第二部分讲解算法中常用的 n & (n - 1) 操作，顺便把用到
     * 这个技巧的算法题列出来讲解一下。因为位操作很简单，所以假设读者已经了解与、或、异或这三种基本操作。
     *
     * 位操作（Bit Manipulation）可以玩出很多奇技淫巧，但是这些技巧大部分都过于晦涩，没必要深究，读者只
     * 要记住一些有用的操作即可。
     *
     *
     *
     * 一、几个有趣的位操作
     *
     * 利用或操作 | 和空格将英文字符转换为小写
     *
     * ('a' | ' ') = 'a'
     * ('A' | ' ') = 'a'
     *
     *
     * 利用与操作 & 和下划线将英文字符转换为大写
     *
     * ('b' & '_') = 'B'
     * ('B' & '_') = 'B'
     *
     *
     * 利用异或操作 ^ 和空格进行英文字符大小写互换
     *
     * ('d' ^ ' ') = 'D'
     * ('D' ^ ' ') = 'd'
     *
     * 以上操作能够产生奇特效果的原因在于 ASCII 编码。字符其实就是数字，恰巧这些字符对应的数字通过位运算
     * 就能得到正确的结果，有兴趣的读者可以查 ASCII 码表自己算算，本文就不展开讲了。
     *
     *
     * 判断两个数是否异号
     *
     * int x = -1, y = 2;
     * bool f = ((x ^ y) < 0); // true
     *
     * int x = 3, y = 2;
     * bool f = ((x ^ y) < 0); // false
     *
     * 这个技巧还是很实用的，利用的是补码编码的符号位。如果不用位运算来判断是否异号，需要使用 if else 分
     * 支，还挺麻烦的。读者可能想利用乘积或者商来判断两个数是否异号，但是这种处理方式可能造成溢出，从而出
     * 现错误。
     *
     *
     * 不用临时变量交换两个数
     *
     * int a = 1, b = 2;
     * a ^= b;
     * b ^= a;
     * a ^= b;
     * // 现在 a = 2, b = 1
     *
     *
     * 加一
     *
     * int n = 1;
     * n = -~n;
     * // 现在 n = 2
     *
     *
     * 减一
     *
     * int n = 2;
     * n = ~-n;
     * // 现在 n = 1
     *
     * PS：上面这三个操作就纯属装逼用的，没啥实际用处，大家了解了解乐呵一下就行。
     *
     *
     *
     * 二、算法常用操作
     *
     * n&(n-1) 这个操作是算法中常见的，作用是消除数字 n 的二进制表示中的最后一个 1。
     *
     * 其核心逻辑就是，n - 1 一定可以消除最后一个 1，同时把其后的 0 都变成 1，这样再和 n 做一次 & 运算，
     * 就可以仅仅把最后一个 1 变成 0 了。
     *
     *
     * 力扣第 191 题，计算汉明权重（Hamming Weight）：
     *
     * 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数
     * （也被称为汉明重量）。
     *
     * 提示：
     * 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整
     * 数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
     *
     * 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整
     * 数 -3。
     *
     *
     * 就是让你返回 n 的二进制表示中有几个 1。因为 n & (n - 1) 可以消除最后一个 1，所以可以用一个循环
     * 不停地消除 1 同时计数，直到 n 变成 0 为止。
     *
     * int hammingWeight(uint32_t n) {
     *     int res = 0;
     *     while (n != 0) {
     *         n = n & (n - 1);
     *         res++;
     *     }
     *     return res;
     * }
     *
     *
     * 力扣第 231 题，判断一个数是不是 2 的指数：
     *
     * 给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。
     *
     * 如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。
     *
     *
     * 一个数如果是 2 的指数，那么它的二进制表示一定只含有一个 1：
     *
     * 2^0 = 1 = 0b0001
     * 2^1 = 2 = 0b0010
     * 2^2 = 4 = 0b0100
     *
     * 如果使用 n&(n-1) 的技巧就很简单了（注意运算符优先级，括号不可以省略）：
     *
     * bool isPowerOfTwo(int n) {
     *     if (n <= 0) return false;
     *     return (n & (n - 1)) == 0;
     * }
     *
     *
     * 力扣第 136 题，查找只出现一次的元素：
     *
     * 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元
     * 素。
     *
     * 说明：
     * 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
     *
     *
     * 这里就可以运用异或运算的性质：
     *
     * 一个数和它本身做异或运算结果为 0，即 a ^ a = 0；一个数和 0 做异或运算的结果为它本身，即 a ^ 0
     * = a。
     *
     * 对于这道题目，只要把所有数字进行异或，成对儿的数字就会变成 0，落单的数字和 0 做异或还是它本身，
     * 所以最后异或的结果就是只出现一次的元素：
     *
     * int singleNumber(vector<int>& nums) {
     *     int res = 0;
     *     for (int n : nums) {
     *         res ^= n;
     *     }
     *     return res;
     * }
     *
     * 以上便是一些有趣/常用的位操作。其实位操作的技巧很多，有一个叫做 Bit Twiddling Hacks 的外国网站
     * 收集了几乎所有位操作的黑科技玩法，感兴趣的读者可以查看：
     *
     * http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel
     */
    public static void main(String[] args) {

    }

}
